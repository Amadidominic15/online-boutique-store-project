# workflow:
#   rules:
#     # Main branch â€” run on normal push/merge commits
#     - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
#       when: always

#     # Prevent other branches from running
#     - when: never

image:
  name: oluwaseuna/aws-k8s-terraform:latest
  entrypoint: [""]

variables:
  HELM_CHART_PATH: "./microservices-chart"
  CHART_NAME: "microservices-chart"
  EKS_CLUSTER_NAME: "online-boutique-eks"
  AWS_DEFAULT_REGION: "eu-west-2"

.default_setup: &deploy
  before_script:
   # Get Web Identity Token
    - >
      export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s"
      $(aws sts assume-role-with-web-identity
      --role-arn ${ROLE_ARN}
      --role-session-name "GitLabRunner-${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
      --web-identity-token ${GITLAB_OIDC_TOKEN}
      --duration-seconds 3600
      --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
      --output text))
    - aws sts get-caller-identity
    # Install Helm
    - apk add --no-cache curl
    - curl https://get.helm.sh/helm-v3.12.0-linux-amd64.tar.gz | tar -xz
    - mv linux-amd64/helm /usr/local/bin/

stages:
  - lint
  - package
  - deploy
  - verify

helm-lint:
  stage: lint
  image: alpine:latest
  tags:
    - aws
    - docker
  before_script:
    - apk add --no-cache curl
    - curl https://get.helm.sh/helm-v3.12.0-linux-amd64.tar.gz | tar -xz
    - mv linux-amd64/helm /usr/local/bin/
  script:
    - helm lint $HELM_CHART_PATH
  rules:
    - if: '$CI_COMMIT_BRANCH == "feature/boutique-helm" && $CI_PIPELINE_SOURCE == "pipeline"'
      when: always

helm-package:
  stage: package
  image: alpine:latest
  tags:
    - aws 
    - docker
  before_script:
    - apk add --no-cache curl
    - curl https://get.helm.sh/helm-v3.12.0-linux-amd64.tar.gz | tar -xz
    - mv linux-amd64/helm /usr/local/bin/
  script:
    - helm package $HELM_CHART_PATH
  artifacts:
    paths:
      - "*.tgz"
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "feature/boutique-helm" && $CI_PIPELINE_SOURCE == "pipeline"'
      when: always

deploy:
  <<: *deploy
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://gitlab.com
  stage: deploy
  tags:
    - aws
    - docker
  script:
    - aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME
    - kubectl get namespace online-boutique || kubectl create namespace online-boutique
    - kubectl get secret my-registry-key -n online-boutique || kubectl create secret docker-registry my-registry-key --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$REG_TOKEN -n online-boutique
    - |
      helm upgrade --install $CHART_NAME $HELM_CHART_PATH \
        --namespace online-boutique \
        --set global.imagePullSecrets[0].name=my-registry-key
  only:
    - main
  when: manual

verify:
  <<: *deploy
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://gitlab.com
  stage: verify
  tags:
    - aws
    - docker
  script:
    - aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $EKS_CLUSTER_NAME
    - echo "Checking deployment status..."
    - kubectl get pods -n online-boutique
    - kubectl get svc -n online-boutique
    - kubectl get ingress -n online-boutique
    - echo "Checking frontend service endpoints..."
    - kubectl get endpoints frontend -n online-boutique
    - echo "Checking if frontend pods are ready..."
    - kubectl wait --for=condition=ready pod -l app=frontend -n online-boutique --timeout=300s
  only:
    - main
  when: manual